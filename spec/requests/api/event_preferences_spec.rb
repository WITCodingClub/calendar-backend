# frozen_string_literal: true

require "rails_helper"

RSpec.describe "Api::EventPreferences", type: :request do
  let(:user) { create(:user) }
  let!(:term) { create(:term) }
  let!(:building) { create(:building, name: "Wentworth Hall") }
  let!(:room) { create(:room, building: building, number: "306") }
  let!(:faculty) { create(:faculty, first_name: "Jane", last_name: "Smith", email: "jane.smith@witcc.edu") }
  let!(:course) do
    create(:course,
           term: term,
           title: "Computer Science I",
           subject: "COMP",
           course_number: "101",
           section_number: "01",
           crn: "12345",
           schedule_type: "laboratory",
           faculties: [faculty])
  end
  let!(:meeting_time) do
    create(:meeting_time,
           course: course,
           room: room,
           day_of_week: "monday",
           begin_time: 900,
           end_time: 1030)
  end
  let(:jwt_token) { JsonWebTokenService.encode(user_id: user.id) }
  let(:headers) { { "Authorization" => "Bearer #{jwt_token}" } }

  before do
    # Enable the v1 feature flag for API access
    Flipper.enable(FlipperFlags::V1, user)
  end


  describe "GET /api/meeting_times/:meeting_time_id/preference" do
    it "accepts public_id in URL" do
      get "/api/meeting_times/#{meeting_time.public_id}/preference", headers: headers

      expect(response).to have_http_status(:ok)
      json = response.parsed_body
      expect(json).to have_key("templates")
    end

    it "includes templates object with all template variable values" do
      get "/api/meeting_times/#{meeting_time.id}/preference", headers: headers

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      expect(json).to have_key("templates")

      templates = json["templates"]
      expect(templates).to include(
        "title"               => "Computer Science I",
        "course_code"         => "COMP-101-01",
        "subject"             => "COMP",
        "course_number"       => 101, # Integer from database
        "section_number"      => "01",
        "crn"                 => 12345, # Integer from database
        "room"                => "306", # String from database
        "building"            => "Wentworth Hall",
        "location"            => "Wentworth Hall - 306",
        "faculty"             => "Jane Smith",
        "faculty_email"       => "jane.smith@witcc.edu",
        "all_faculty"         => "Jane Smith",
        "start_time"          => "9:00 AM",
        "end_time"            => "10:30 AM",
        "day"                 => "Monday",
        "day_abbr"            => "Mon",
        "schedule_type"       => "Laboratory", # Capitalized by template renderer
        "schedule_type_short" => "Lab"
      )
      # Term is randomly generated by factory, so just verify it exists
      expect(templates["term"]).to match(/\A(Spring|Summer|Fall) \d{4}\z/)
    end

    it "still includes all other response fields" do
      get "/api/meeting_times/#{meeting_time.id}/preference", headers: headers

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      expect(json).to have_key("individual_preference")
      expect(json).to have_key("resolved")
      expect(json).to have_key("sources")
      expect(json).to have_key("preview")
    end

    it "transforms 'popup' to 'notification' in reminder settings" do
      get "/api/meeting_times/#{meeting_time.id}/preference", headers: headers

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      resolved = json["resolved"]
      reminder_settings = resolved["reminder_settings"]

      # Default system reminder uses "popup" internally but should be transformed to "notification"
      expect(reminder_settings).to be_an(Array)
      expect(reminder_settings.first).to include(
        "time" => "30",
        "type" => "minutes",
        "method" => "notification" # Should be "notification", not "popup"
      )
    end

    it "transforms 'popup' to 'notification' in custom event preference reminder settings" do
      # Create an event preference with popup reminders
      EventPreference.create!(
        user: user,
        preferenceable: meeting_time,
        reminder_settings: [
          { "time" => "15", "type" => "minutes", "method" => "popup" },
          { "time" => "1", "type" => "hours", "method" => "popup" }
        ]
      )

      get "/api/meeting_times/#{meeting_time.id}/preference", headers: headers

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      individual = json["individual_preference"]
      reminder_settings = individual["reminder_settings"]

      # Both reminders should have "notification" instead of "popup"
      expect(reminder_settings).to be_an(Array)
      expect(reminder_settings.length).to eq(2)
      expect(reminder_settings[0]).to include(
        "time" => "15",
        "type" => "minutes",
        "method" => "notification"
      )
      expect(reminder_settings[1]).to include(
        "time" => "1",
        "type" => "hours",
        "method" => "notification"
      )
    end
  end

  describe "PUT /api/meeting_times/:meeting_time_id/preference" do
    before do
      # Stub sync job to avoid Google credential dependency
      allow(SyncMeetingTimeJob).to receive(:perform_now)
      allow(SyncMeetingTimeJob).to receive(:perform_later)
    end

    it "includes templates object in update response" do
      put "/api/meeting_times/#{meeting_time.id}/preference",
          params: {
            event_preference: {
              color_id: 5
            }
          },
          headers: headers,
          as: :json

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      expect(json).to have_key("templates")
      expect(json["templates"]).to include(
        "title"       => "Computer Science I",
        "course_code" => "COMP-101-01"
      )
    end

    it "allows setting reminder_settings to empty array (no notifications)" do
      put "/api/meeting_times/#{meeting_time.id}/preference",
          params: {
            event_preference: {
              reminder_settings: []
            }
          },
          headers: headers,
          as: :json

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      expect(json["individual_preference"]["reminder_settings"]).to eq([])
      expect(json["resolved"]["reminder_settings"]).to eq([])
    end

    it "allows updating only reminder_settings with empty array when no other changes" do
      # First create a preference with some settings
      put "/api/meeting_times/#{meeting_time.id}/preference",
          params: {
            event_preference: {
              color_id: 5,
              reminder_settings: [{ time: "30", type: "minutes", method: "notification" }]
            }
          },
          headers: headers,
          as: :json

      expect(response).to have_http_status(:ok)

      # Now update only reminder_settings to empty array
      put "/api/meeting_times/#{meeting_time.id}/preference",
          params: {
            event_preference: {
              reminder_settings: []
            }
          },
          headers: headers,
          as: :json

      expect(response).to have_http_status(:ok)

      json = response.parsed_body
      expect(json["individual_preference"]["reminder_settings"]).to eq([])
      expect(json["resolved"]["reminder_settings"]).to eq([])
      # Color should be preserved
      expect(json["individual_preference"]["color_id"]).to eq("#f6bf26") # Color 5 = WITCC_BANANA
    end

    it "converts WITCC hex color to Google color ID in DB and returns WITCC hex in response" do
      put "/api/meeting_times/#{meeting_time.id}/preference",
          params: {
            event_preference: {
              color_id: "#d50000" # WITCC_TOMATO
            }
          },
          headers: headers,
          as: :json

      expect(response).to have_http_status(:ok)

      # Verify that the color was converted to Google's color ID 11 (EVENT_TOMATO) in the database
      preference = EventPreference.find_by(user: user, preferenceable: meeting_time)
      expect(preference.color_id).to eq(11)

      # Verify that the API returns the WITCC hex color
      json = response.parsed_body
      expect(json["individual_preference"]["color_id"]).to eq("#d50000")
      expect(json["resolved"]["color_id"]).to eq("#d50000")
    end

    it "handles multiple WITCC colors correctly" do
      # Test WITCC_PEACOCK -> EVENT_PEACOCK (color ID 7) -> WITCC_PEACOCK
      put "/api/meeting_times/#{meeting_time.id}/preference",
          params: {
            event_preference: {
              color_id: "#039be5"
            }
          },
          headers: headers,
          as: :json

      expect(response).to have_http_status(:ok)

      # Verify database storage
      preference = EventPreference.find_by(user: user, preferenceable: meeting_time)
      expect(preference.color_id).to eq(7)

      # Verify API response
      json = response.parsed_body
      expect(json["individual_preference"]["color_id"]).to eq("#039be5")
    end
  end
end
